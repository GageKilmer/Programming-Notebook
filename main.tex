\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage{xcolor}
\usepackage[margin=0.5in]{geometry}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=1pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    numbers=none
}

\lstset{style=mystyle}

\title{Programming Notebook}
\author{Gage H. Kilmer}
\date{Last Updated: July 2024}

\begin{document}

\maketitle

\newpage
\section{General Programming}
\subsection{Review Questions}

\newpage
\section{C\# Programming}

\subsection{Review Questions}
\begin{itemize}
    \item What is the .NET SDK?
    \begin{itemize}
        \item The .NET Standard Developer Kit contains the .NET Command Line Interface (CLI), the .NET runtime, as well as a myriad of tools and libraries to enable a developer to build and deploy applications. 
    \end{itemize}
    \item What is the .NET Runtime?
    \begin{itemize}
        \item The .NET Runtime contains all the necessary infrastructure for a device to run a .NET application.
    \end{itemize}
        \item What is a \textit{self-contained deployment}?
    \begin{itemize}
        \item A self-contained deployment is when an application comes prepackaged with the necessary runtime for it to run.
    \end{itemize}
    \item Is C\# a \textit{managed code} or \textit{unmanaged code} language, and what does that mean?
    \begin{itemize}
        \item C\# is typically used to create managed code, though using the \textit{unsafe} keyword allows you to directly manipulate memory, which makes unmanaged code. Additionally, you can implement interoperability with unmanaged code .dll files.
        \item Managed code is compiled into an intermediate language, to be interpreted by a language runtime, such as the Common Language Runtime (CLR). It typically has automatic memory management (garbage collection) and offers greater cross-platform support, as many of the details of hardware implementation are handled by the runtime.
        \item Unmanaged code is compiled to machine language, and allows greater control over low-level operations, including manual memory management. However it also requires the developer to properly handle the additional responsibilities.
    \end{itemize}
    \item What are ``Top-level statements" in C\#?
    \begin{itemize}
        \item Starting with C\#9, simple applications can be written that do not require explicit definitions of a namespace, a main function, or even a class.
    \end{itemize}
    \item What is the \textit{var} keyword and how is it used?
    \begin{itemize}
        \item The var keyword is used to declare a variable using type inference, in essence the compiler interprets the data type that is being stored and treats the variable as such. 
        \item It is necessary to use for anonymous functions, however it is otherwise a stylistic choice that should generally be avoided as it reduces code readability.
    \end{itemize}
    \item What is the \textit{const} keyword?
    \begin{itemize}
        \item The const keyword marks that a variable should never be changed, ideally even in future versions of the program (Otherwise it will need to be recompiled for the change to be reflected).
        \item Variables with the const keyword \textbf{must} be initialized to a value when they are declared, and that value must be known at compile-time (cannot come from another variable).
        \item Additionally, const variables are always static, and cannot be used with the static keyword.
    \end{itemize}
    \item What are ``nullable value types?"
    \begin{itemize}
        \item Nullable value types were introduced in C\#2, and by using the ? operator, it allows you to set value type variables to null
        \item Behind the scenes
        \begin{lstlisting}[language=C++]
            int? myInt; \end{lstlisting} is interpreted by the compiler as
            \begin{lstlisting}[language=C++]
            Nullable<int> myInt; \end{lstlisting}
        \item Nullable types have a property called \textit{hasValue} which returns true if it is not null, and false if it is 
    \end{itemize}
    \item What are ``nullable reference types?"
    \begin{itemize}
        \item Nullable reference types throw compiler warnings when they are not checked for null value, to reduce the risk of \textit{NullReferenceException} errors
        \item Additionally, with this enabled, non-nullable reference types can no longer be set to null without throwing compiler warnings.
        \item C\# 8 introduced nullable reference types, and they must be explicitly enabled.
    \end{itemize}
    \item What is the \textit{?.} operator?
    \begin{itemize}
        \item The ?. operator is called the null-conditional operator, and it checks if the calling object is null before invoking the method. 
        \item Example: \begin{lstlisting}[language=C++]
            myObject?.method(); \end{lstlisting}
        \item The result of a method called this way cannot be assigned to a non-nullable type, as they will return null if the calling object is null.
        \item Valid Example:
            \begin{lstlisting}[language=C++]
            string? objectName = myObject?.getName(); \end{lstlisting} 
    \end{itemize}
    \item What is the \textit{??} operator?
    \begin{itemize}
        \item The coalescing operator is used to return a different value if the left-hand expression evaluates to null.
        \item Example which returns 0 if an int is null:
        \begin{lstlisting}[language=C++]
            int? firstInt = null;
            int? secondInt = firstInt ?? 0\end{lstlisting} 
    \end{itemize}
    \item What is the difference between reference and value types?
    \begin{itemize}
        \item Value types contain the value of the variable, and when they are passed as parameters to functions, a new copy of the value type variable is made.
        \item Reference types instead hold a pointer to the original data, and as such when they are passed as parameters, changes made within the function are reflected in the original.
    \end{itemize}
    \item What are the different value and reference types?
    \begin{itemize}
        \item Reference types: Class, String, Dynamic, Object, Interface, Record, Delegate
        \item Value types: Anything else, notably including structs
    \end{itemize}
    \item What are the different integer types in C\#?
    \begin{itemize}
        \item The byte and sbyte types have 8 bits, and can represent [0,255] and [-128,127] respectively
        \item The short and ushort types have 16 bits, and can represent [-32768, 32767] and [0, 65535] respectively
        \item The int type is a signed 32-bit integer, and uint is an unsigned 32-bit integer
        \item Likewise, long and ulong are 64-bit integers.
        \item Lastly, there is the BigInteger data type, which has no upper and lower bounds, but will dynamically resize itself as long as there is enough memory to do so.
    \end{itemize}
    \item What is the purpose of underscores when working with numerical values?
    \begin{itemize}
        \item They can be used as separators that are ignored by the compiler to improve code readability.
        \item This is especially helpful when working with binary data via the 0b literal.
    \end{itemize}
    \item What are the different floating point types in C\#?
    \begin{itemize}
        \item System.Half is a 16-bit floating point type.
        \item System.Single (float) is a 32-bit floating point type, used by adding an ``f" to the value.
        \item System.Double (double) is a 64-bit floating point type.
        \item System.Decimal (decimal) is a 128-bit floating point type, used my adding an ``m" to the value.
    \end{itemize}
    \item What integer values map to which boolean values in C\#?
    \begin{itemize}
        \item You cannot convert between integers and booleans in C\#.
    \end{itemize}
    \item What is ``pattern matching?"
    \begin{itemize}
        \item Pattern matching allows simpler syntax to check whether data matches some given pattern. There are many types of pattern matching that each have different uses. They are most commonly used with conditional statements, switch statements, and switch expressions.
    \end{itemize}
    \item What are the different types of pattern matching?
    \begin{itemize}
        \item Type Pattern: Checks if the data is castable to a given type. Putting an identifier after the data type does the cast and stores the result to that new variable.
         \begin{lstlisting}[language=C++]
            if(myValue is int)
            if(myValue is int newValue)\end{lstlisting}
        \item Const Pattern: Checks if the data is equal to a given value, including null.
         \begin{lstlisting}[language=C++]
            if(myValue is 32)
            if(myValue is null)\end{lstlisting} 
        \item Relational Pattern: Checks if the data has some given relationship to a given value.
        \begin{lstlisting}[language=C++]
            if(myValue is >= 32)
            switch(myValue)
                case == 3:\end{lstlisting} 
        \item Property Pattern: Checks the value of a named property on the given object.
            \begin{lstlisting}[language=C++]
                if(myString is {Length: 4}) \end{lstlisting} 
        \item Positional Pattern: Checks if a group of values in parentheses match the values in a tuple, positional record, or a type which has a defined \textit{Deconstruct()} method. Any value checked against an underscore is treated as a wildcard.
        
                \begin{lstlisting}[language=C++]
                if(myPair is (false, false))
                if(myCoords is (0.5f, _, 0.5f))\end{lstlisting}
        \item Var Pattern: The var pattern always succeeds, as it doesn't check for anything, but instead stores an expression into a var.
        \begin{lstlisting}[language=C++]
                if(getData() is var myData && myData.value is 32) \end{lstlisting} 
    \end{itemize}

    \item What are Pattern Combinators/Logical Patterns?
    \begin{itemize}
        \item The three pattern combinators are \textit{not, and,} and \textit{or}.
        \item They act as ways to combine multiple patterns together for more complex checking
        \begin{lstlisting}[language=C++]
                if(myValue is < 0 or >100 and not 32) \end{lstlisting} 
    \end{itemize}
    \item What are the differences between Casting, Converting, and Parsing data?
    \begin{itemize}
        \item Casting tells the compiler that one piece of data should be interpreted as a different data type. No data is changed, but data can be lost when casting from a higher precision type to a lower precision type. For example, a float to an int.
        \item Conversion is typically an actual software function call which takes in one data type and returns another. Data may be changed during this call.
        \item Parsing is a special subset of conversion where a string is converted to a different data type if it can properly be represented as such.
    \end{itemize}
    \item What is the difference between the String class and the StringBuilder class?
    \begin{itemize}
        \item Technically strings are an immutable type in C\#, they cannot be modified. If you do someString += "a", you are actually creating an entirely new string object which is inefficient
        \item StringBuilders are a mutable type that allow you to modify strings without creating new objects
    \end{itemize}
    \item What is String Interpolation?
    \begin{itemize}
        \item String interpolation allows you to insert expressions and variables into strings by beginning the string with a \$ and putting any expressions within brackets.
        \begin{lstlisting}[language=C++]
                Console.Writeln($"My name is {Name.first} {Name.last}, and my initials are {Name.first[0] + Name.last[0]}"); \end{lstlisting} 
    \end{itemize}
    \item What is the FormattableString type?
    \begin{itemize}
        \item Formattable strings are strings which contain Format, GetArgument, and ArgumentCount members, which allow you to directly check and write information relating to an interpolated strings formatting.
    \end{itemize}
    \item What are Verbatim Strings?
    \begin{itemize}
        \item Verbatim strings ignore any escape characters and are stored exactly as they are written.
        \item They are declared by prefixing a string with the @ symbol.
        \begin{lstlisting}[language=C++]
                Console.Writeln(@"C:\Users\User"); \end{lstlisting} 
    \end{itemize}
\end{itemize}


\newpage
\section{C++ Programming}
\subsection{Review Questions}

\newpage
\section{Unity Game Development}
\subsection{Useful Functions to Remember}
\begin{itemize}
    \item Transform.LookAt - Sets the forward vector of the calling transform to be facing towards the target transform
    \begin{lstlisting}[language=C++]
                myTransform.LookAt(Transform target); \end{lstlisting} 
    \item Vector3.Magnitude - Gets the magnitude (length) of a vector
    \begin{lstlisting}[language=C++]
                float distance = vectorToTarget.magnitude; \end{lstlisting}
    \item Vector3.SqrMagnitude - Gets the magnitude (length) of a vector squared. Useful because it is much faster than Vector3.magnitude, as it doesn't require a square root operation.
    \begin{lstlisting}[language=C++]
                float distance = vectorToTarget.sqrMagnitude; \end{lstlisting}
    \item Vector3.Distance - Static, gets the distance between two transforms
    \begin{lstlisting}[language=C++]
                float distance = Vector3.Distance(myPos, targetPos); \end{lstlisting}
    \item Debug.DrawRay - Static, draws a ray from a starting position along a given vector.
    \begin{lstlisting}[language=C++]
                Debug.DrawRay(myPos, vectorToTrack, myColor, durationInSeconds); \end{lstlisting}
    \item Vector3.Dot - Static, calculates the dot product of two vectors.
    \begin{lstlisting}[language=C++]
                float dotProduct = Vector3.Dot(vecA, vecB); \end{lstlisting}
    
\end{itemize}
\subsection{Review Questions}

\newpage
\section{Unreal Engine Game Development}

\subsection{Review Questions}

\newpage
\section{General Mathematics \& Physics}
\subsection{Mathematics}
\begin{itemize}
    \item What is a Dot Product?
    \begin{itemize}
        \item The dot product is the sum of the multiplication of two vectors by their components
        \item To get the dot product of vectors a and b we use the formula $a.x*b.x + a.y*b.y$
        \item A right angle has a dot product of $0$, acute angles have positive dot products, and obtuse angles have negative dot products.
        \item This can be used to identify the relative positioning of an object in space
        \item Additionally the angle $\theta$ can be calculated via the formula $\theta = cos^{-1}(\frac{a \cdot b}{||a||*||b||})$ 
        \item Normalized vectors return $1$ if they face the same direction and $-1$ if they face opposite directions.
    \end{itemize}
    \item What is a Cross Product?
    \begin{itemize}
        \item Cross product returns a vector which is orthogonal to both of its input vectors.
        \item The cross product of vectors $a$ and $b$ can be calculated by the formula:
        $\newline (a.y*b.z - a.z*b.y), (a.z*b.x - a.x*b.z), (a.x*b.y - a.y*b.x)$ 
        \item The sign of the resultant vectors components can show whether a clockwise or counterclockwise turn on a given axis will get the first vector to line up with the second. Positive for clockwise, and negative for counterclockwise.
    \end{itemize}
\end{itemize}
\end{document}
