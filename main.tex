\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\usepackage{listings}
\usepackage{xcolor}
\usepackage[margin=0.5in]{geometry}
\usepackage{hyperref} %Must be last package

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=1pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    numbers=none
}

\lstset{style=mystyle}

\title{Programming Notebook}
\author{Gage H. Kilmer}
\date{Last Updated: July 2024}

\begin{document}

\maketitle

\newpage
\tableofcontents

\newpage
\section{General Programming}
\subsection{Review Questions}
\subsection{Algorithms}
\subsubsection{The A* Algorithm}
\begin{itemize}
    \item The A* Algorithm is a node-based pathfinding algorithm which uses a cost value based on distance traveled and distance to goal to determine the best path
    \item The node structure should contain fields for $distanceFromOrigin$, $distanceToEndpoint$, $totalScore$
    and $parentNode$
    \begin{itemize}
        \item $distanceFromOrigin$ is cumulative based on the distance from the previous node
        \item $distanceToEndpoint$ can be any form of distance calculation, like taxicab or direct
        \item $totalCost$ is the sum of $distanceFromOrigin$ and $distanceToEndpint$
    \end{itemize}
    \item The basic process for the A* algorithm is as follows:
    \begin{itemize}
        \item Create two empty lists of nodes, $nodesToCheck$ and $checkedNodes$.
        \item Add the starting node to the list of nodes to check
        \item Check to see if any of the neighboring nodes to the current node are valid, and if so, calculate their $totalCost$ add them to the $nodesToCheck$ list.
        \item Sort the $nodesToCheck$ list by the $totalCost$ of its elements
        \item Move the current node to $checkedNodes$
        \item Grab the first element of $nodesToCheck$, check if it is the destination, and if not, repeat from step 3.
        \item Once the grabbed node is the destination, work backwards through the parents of each node to get the best path.
    \end{itemize}
    \item The $totalCost$ field of a node can incorporate additional information to guide the algorithm towards a more ``ideal" path
    \item There may be an additional value added to $totalCost$ for ``lava tiles" that deal damage to the character walking over them.
    \item This, in turn, disincentivizes the path without outright removing it from consideration.
\end{itemize}

\subsection{Design Patterns}
\subsubsection{Singleton}
\begin{itemize}
    \item Singletons are a design pattern characterized by a class with a single globally accessible instance.
    \item The singleton is implemented by having a private constructor, so that no other instances of the class can be created, and by having a public static instance of the class within its definition that can be accessed from anywhere.
\end{itemize}

\subsubsection{Command}
\begin{itemize}
    \item The command design pattern is a general term that refers to storing a function call as an object. This object can then be passed as an argument to a function, can be added to a queue or invoked at a specified time, and implement undo/redo functionality.
    \item In C++ this can take the form of function pointers, In C\# this is called a delegate. Other languages use the terms first-order function, callback, or closure, each with their own unique properties.
    \item There are four key aspects to the Command structure
    \begin{itemize}
        \item Command Interface: the abstract base class that acts as a framework for minimum functionality any derived command classes need to implement.
        \item Concrete Command Classes: The derived classes of the command interface, which call actually implemented functions from the receiver. The concrete command classes should contain almost no actual implementations, but must contain fields for any necessary parameters of the callback function they invoke.
        \item Receiver: The device that implements the desired functionality. The receiver class can be an abstract base class allowing for greater extensibility via derived classes if desired.
        \item Invoker/Sender: The invoker is the class that actually calls the $command.execute()$ function from a reference to a command instance, and it has no knowledge of the implementation of the underlying method call, or of the command class it is invoking.
    \end{itemize}
    \item An object-oriented implementation to decouple input buttons and game functionality could be as such
    \begin{itemize}
        \item An abstract base Command class with derived classes that implement the game functions as overrides to an invoke function. 
        \item Each input button then invokes the function pointer within the Command class, such that which derived class instance is tied to which input can be changed, allowing for buttons to be remapped
        \item Additionally, if we decouple the actor that is being affected by user inputs from the user inputs, the command structure becomes a powerful interface for AI systems to control any actor that uses the same functionality.
    \end{itemize}
    \item In the previous example, only one instance of the derived classes of Command need to be created, and they can be reused. However, in some cases you may want to keep command instances in a buffer, which allows you to implement an undo function, as is common in many tactical style games.
    \item An important distinction here is that the first example decoupling the actor from the command was a desired feature, as it allowed other units to utilize the same structure. 
\end{itemize}
\subsubsection{Flyweight}
\begin{itemize}
    \item The flyweight is a structural design pattern characterized by separation of the intrinsic and extrinsic state of an object.
    \begin{itemize}
        \item Intrinsic State: Things that never change between instances of an object. Ex. Model, list of potential textures, etc.
        \item Extrinsic State: Things that differ between instances of an object. Ex. Position, Rotation, HP, etc.
    \end{itemize}
    \item In ``Game Programming Patterns" by Robert Nystrom, the flyweight pattern is described as one where there are many instances of a small class which only contains the extrinsic state of the object, and a reference to a single copy of an object which contains the intrinsic state of an object.
    \item This contrasts with \href{https://refactoring.guru/design-patterns/flyweight}{refactoring.guru's} example, where a Factory class creates new instances of the Flyweight class (which contains intrinsic state) if no such instance exists, and returns the existing instance if it does exist. 
    \begin{itemize}
        \item This paradigm has each flyweight (intrinsic) class holding all of the methods relating to the class, with the extrinsic class passing in any necessary information for that method to run.
    \end{itemize}
    \item Personally I feel that, in languages that support static fields, the best way to implement a flyweight-style separation of intrinsic and extrinsic data is via static fields. \item I think that holding the intrinsic state in static fields and extrinsic state in non-static fields has the best balance of performance and readability. \item It is worth noting that with the static field method, each instance of the extrinsic class must contain a reference to the intrinsic data by nature of how static members work. This is not necessarily true using Nystrom's version.
\end{itemize}

\newpage
\section{C\# Programming}

\subsection{Review Questions}
\begin{itemize}
    \item What is the .NET SDK?
    \begin{itemize}
        \item The .NET Standard Developer Kit contains the .NET Command Line Interface (CLI), the .NET runtime, as well as a myriad of tools and libraries to enable a developer to build and deploy applications. 
    \end{itemize}
    \item What is the .NET Runtime?
    \begin{itemize}
        \item The .NET Runtime contains all the necessary infrastructure for a device to run a .NET application.
    \end{itemize}
        \item What is a \textit{self-contained deployment}?
    \begin{itemize}
        \item A self-contained deployment is when an application comes prepackaged with the necessary runtime for it to run.
    \end{itemize}
    \item Is C\# a \textit{managed code} or \textit{unmanaged code} language, and what does that mean?
    \begin{itemize}
        \item C\# is typically used to create managed code, though using the \textit{unsafe} keyword allows you to directly manipulate memory, which makes unmanaged code. Additionally, you can implement interoperability with unmanaged code .dll files.
        \item Managed code is compiled into an intermediate language, to be interpreted by a language runtime, such as the Common Language Runtime (CLR). It typically has automatic memory management (garbage collection) and offers greater cross-platform support, as many of the details of hardware implementation are handled by the runtime.
        \item Unmanaged code is compiled to machine language, and allows greater control over low-level operations, including manual memory management. However it also requires the developer to properly handle the additional responsibilities.
    \end{itemize}
    \item What are ``Top-level statements" in C\#?
    \begin{itemize}
        \item Starting with C\#9, simple applications can be written that do not require explicit definitions of a namespace, a main function, or even a class.
    \end{itemize}
    \item What is the \textit{var} keyword and how is it used?
    \begin{itemize}
        \item The var keyword is used to declare a variable using type inference, in essence the compiler interprets the data type that is being stored and treats the variable as such. 
        \item It is necessary to use for anonymous functions, however it is otherwise a stylistic choice that should generally be avoided as it reduces code readability.
    \end{itemize}
    \item What is the \textit{const} keyword?
    \begin{itemize}
        \item The const keyword marks that a variable should never be changed, ideally even in future versions of the program (Otherwise it will need to be recompiled for the change to be reflected).
        \item Variables with the const keyword \textbf{must} be initialized to a value when they are declared, and that value must be known at compile-time (cannot come from another variable).
        \item Additionally, const variables are always static, and cannot be used with the static keyword.
    \end{itemize}
    \item What are ``nullable value types?"
    \begin{itemize}
        \item Nullable value types were introduced in C\#2, and by using the ? operator, it allows you to set value type variables to null
        \item Behind the scenes
        \begin{lstlisting}[language=C++]
            int? myInt; \end{lstlisting} is interpreted by the compiler as
            \begin{lstlisting}[language=C++]
            Nullable<int> myInt; \end{lstlisting}
        \item Nullable types have a property called \textit{hasValue} which returns true if it is not null, and false if it is 
    \end{itemize}
    \item What are ``nullable reference types?"
    \begin{itemize}
        \item Nullable reference types throw compiler warnings when they are not checked for null value, to reduce the risk of \textit{NullReferenceException} errors
        \item Additionally, with this enabled, non-nullable reference types can no longer be set to null without throwing compiler warnings.
        \item C\# 8 introduced nullable reference types, and they must be explicitly enabled.
    \end{itemize}
    \item What is the \textit{?.} operator?
    \begin{itemize}
        \item The ?. operator is called the null-conditional operator, and it checks if the calling object is null before invoking the method. 
        \item Example: \begin{lstlisting}[language=C++]
            myObject?.method(); \end{lstlisting}
        \item The result of a method called this way cannot be assigned to a non-nullable type, as they will return null if the calling object is null.
        \item Valid Example:
            \begin{lstlisting}[language=C++]
            string? objectName = myObject?.getName(); \end{lstlisting} 
    \end{itemize}
    \item What is the \textit{??} operator?
    \begin{itemize}
        \item The coalescing operator is used to return a different value if the left-hand expression evaluates to null.
        \item Example which returns 0 if an int is null:
        \begin{lstlisting}[language=C++]
            int? firstInt = null;
            int? secondInt = firstInt ?? 0\end{lstlisting} 
    \end{itemize}
    \item What is the difference between reference and value types?
    \begin{itemize}
        \item Value types contain the value of the variable, and when they are passed as parameters to functions, a new copy of the value type variable is made.
        \item Reference types instead hold a pointer to the original data, and as such when they are passed as parameters, changes made within the function are reflected in the original.
    \end{itemize}
    \item What are the different value and reference types?
    \begin{itemize}
        \item Reference types: Class, String, Dynamic, Object, Interface, Record, Delegate
        \item Value types: Anything else, notably including structs
    \end{itemize}
    \item What are the different integer types in C\#?
    \begin{itemize}
        \item The byte and sbyte types have 8 bits, and can represent [0,255] and [-128,127] respectively
        \item The short and ushort types have 16 bits, and can represent [-32768, 32767] and [0, 65535] respectively
        \item The int type is a signed 32-bit integer, and uint is an unsigned 32-bit integer
        \item Likewise, long and ulong are 64-bit integers.
        \item Lastly, there is the BigInteger data type, which has no upper and lower bounds, but will dynamically resize itself as long as there is enough memory to do so.
    \end{itemize}
    \item What is the purpose of underscores when working with numerical values?
    \begin{itemize}
        \item They can be used as separators that are ignored by the compiler to improve code readability.
        \item This is especially helpful when working with binary data via the 0b literal.
    \end{itemize}
    \item What are the different floating point types in C\#?
    \begin{itemize}
        \item System.Half is a 16-bit floating point type.
        \item System.Single (float) is a 32-bit floating point type, used by adding an ``f" to the value.
        \item System.Double (double) is a 64-bit floating point type.
        \item System.Decimal (decimal) is a 128-bit floating point type, used my adding an ``m" to the value.
    \end{itemize}
    \item What integer values map to which boolean values in C\#?
    \begin{itemize}
        \item You cannot convert between integers and booleans in C\#.
    \end{itemize}
    \item What is ``pattern matching?"
    \begin{itemize}
        \item Pattern matching allows simpler syntax to check whether data matches some given pattern. There are many types of pattern matching that each have different uses. They are most commonly used with conditional statements, switch statements, and switch expressions.
    \end{itemize}
    \item What are the different types of pattern matching?
    \begin{itemize}
        \item Type Pattern: Checks if the data is castable to a given type. Putting an identifier after the data type does the cast and stores the result to that new variable.
         \begin{lstlisting}[language=C++]
            if(myValue is int)
            if(myValue is int newValue)\end{lstlisting}
        \item Const Pattern: Checks if the data is equal to a given value, including null.
         \begin{lstlisting}[language=C++]
            if(myValue is 32)
            if(myValue is null)\end{lstlisting} 
        \item Relational Pattern: Checks if the data has some given relationship to a given value.
        \begin{lstlisting}[language=C++]
            if(myValue is >= 32)
            switch(myValue)
                case == 3:\end{lstlisting} 
        \item Property Pattern: Checks the value of a named property on the given object.
            \begin{lstlisting}[language=C++]
                if(myString is {Length: 4}) \end{lstlisting} 
        \item Positional Pattern: Checks if a group of values in parentheses match the values in a tuple, positional record, or a type which has a defined \textit{Deconstruct()} method. Any value checked against an underscore is treated as a wildcard.
        
                \begin{lstlisting}[language=C++]
                if(myPair is (false, false))
                if(myCoords is (0.5f, _, 0.5f))\end{lstlisting}
        \item Var Pattern: The var pattern always succeeds, as it doesn't check for anything, but instead stores an expression into a var.
        \begin{lstlisting}[language=C++]
                if(getData() is var myData && myData.value is 32) \end{lstlisting} 
    \end{itemize}

    \item What are Pattern Combinators/Logical Patterns?
    \begin{itemize}
        \item The three pattern combinators are \textit{not, and,} and \textit{or}.
        \item They act as ways to combine multiple patterns together for more complex checking
        \begin{lstlisting}[language=C++]
                if(myValue is < 0 or >100 and not 32) \end{lstlisting} 
    \end{itemize}
    \item What are the differences between Casting, Converting, and Parsing data?
    \begin{itemize}
        \item Casting tells the compiler that one piece of data should be interpreted as a different data type. No data is changed, but data can be lost when casting from a higher precision type to a lower precision type. For example, a float to an int.
        \item Conversion is typically an actual software function call which takes in one data type and returns another. Data may be changed during this call.
        \item Parsing is a special subset of conversion where a string is converted to a different data type if it can properly be represented as such.
    \end{itemize}
    \item What is the difference between the String class and the StringBuilder class?
    \begin{itemize}
        \item Technically strings are an immutable type in C\#, they cannot be modified. If you do someString += "a", you are actually creating an entirely new string object which is inefficient
        \item StringBuilders are a mutable type that allow you to modify strings without creating new objects
    \end{itemize}
    \item What is String Interpolation?
    \begin{itemize}
        \item String interpolation allows you to insert expressions and variables into strings by beginning the string with a \$ and putting any expressions within brackets.
        \begin{lstlisting}[language=C++]
                Console.Writeln($"My name is {Name.first} {Name.last}, and my initials are {Name.first[0] + Name.last[0]}"); \end{lstlisting} 
    \end{itemize}
    \item What is the FormattableString type?
    \begin{itemize}
        \item Formattable strings are strings which contain Format, GetArgument, and ArgumentCount members, which allow you to directly check and write information relating to an interpolated strings formatting.
    \end{itemize}
    \item What are Verbatim Strings?
    \begin{itemize}
        \item Verbatim strings ignore any escape characters and are stored exactly as they are written.
        \item They are declared by prefixing a string with the @ symbol.
        \begin{lstlisting}[language=C++]
                Console.Writeln(@"C:\Users\User"); \end{lstlisting} 
    \end{itemize}
    \item What are the different access modifiers in C\#?
    \begin{itemize}
        \item Public: Accessible from anywhere in the code.
        \item Private: Accessible only from the containing class.
        \item Protected: Accessible from the containing class and any derived classes.
        \item Internal: Accessible from the containing class and anywhere in the same assembly 
        \item Protected Internal: Accessible from the containing class, anywhere in the same assembly, and derived classes anywhere.
        \item Private Protected: Accessible only from the containing class and derived classes \textbf{in the same assembly}.
    \end{itemize}
    \item What are the differences between the \textit{const} and \textit{readonly} keywords?
    \begin{itemize}
        \item Const fields are known at compile-time, and they cannot be changed at all once set. They must be initialized to a value when declared, and are always intrinsically static.
        \item Readonly fields are able to be set at runtime, and they can be changed without limitation within the constructor of the containing object. They can be static or instance variables.
    \end{itemize}
    \item What are the differences between the equivalence semantics for value and reference types?
    \begin{itemize}
        \item When checking if two value types are equal, the default behaviour is to return true if every data member of the $a$ and $b$ are equal.
        \item When checking if two reference types are equal, the default behaviour is to return true only if both $a$ and $b$ point to the same location in memory.
        \item These behaviours can be changed by overriding the Equals and GetHashCode functionality.
    \end{itemize}
    \item What are ``Properties" in C\#?
    \begin{itemize}
        \item Properties are private fields made accessible through getter and setter accessor functions.
        \item Accessor functions can be auto-implemented, and may also allow for default values to be set.
        \begin{lstlisting}[language=C++]
                public int MyInt {get; set;} = 112; \end{lstlisting} 
        \item Auto-implemented accessors can have their accessibility explicitly set.
        \begin{lstlisting}[language=C++]
                public int MyInt {public get; private set;} = 112; \end{lstlisting}
        \item Properties can be made readonly by simply not implementing a set accessor.
        \begin{lstlisting}[language=C++]
                public int MyInt {get; } = 112; \end{lstlisting}
        \item Properties can be accessed as if they were public fields without breaking encapsulation.
    \end{itemize}
    \item What are ``expression-bodied properties"?
    \begin{itemize}
        \item Expression-bodied properties are read-only properties implemented with the $=>$ syntax.
        \item The compiler automatically generates a public get accessor for the property
         \begin{lstlisting}[language=C++]
                private readonly string ReturnThisValue;
                public string CallThisAccessor => ReturnThisValue;\end{lstlisting}
    \end{itemize}
    \item What are ``init-only set accessors"?
    \begin{itemize}
        \item Init-only set accesssors are used to create set accessors which can only be used from a constructor or an object initializer.
        \begin{lstlisting}[language=C++]
                public class MyClass
                {
                    public string initOnly {get; init;} = "Default";
                }
                //Valid
                myClass = new MyClass(){initOnly = "New Value";}

                //Not valid
                myClass = new MyClass();
                myClass.initOnly = "New Value";
                \end{lstlisting}
    \end{itemize}
    \item What is the difference between a function and a method in C\# nomenclature?
    \begin{itemize}
        \item Methods specifically refer to callable code chunks which may accept parameters and may return values.
        \item Function members are a more general term that includes methods, but may also refer to any non-data member of a class.
    \end{itemize}
    \item What is an ``Expression-Bodied Method?"
    \begin{itemize}
        \item An expression-bodied method is a method which only contains a single statement and is written using the $=>$ syntax;
        \begin{lstlisting}[language=C++]
                private void myFunction() => doSomething;\end{lstlisting}
    \end{itemize}
    \item What is method overloading?
    \begin{itemize}
        \item Method overloading is a form of compile-time polymorphism that allows you to define the same method using multiple different input parameters to call different implementations.
        \item Additionally, an overloaded method can invoke a different overload of the same method within its implementation.
    \end{itemize}
    \item What are named arguments and how/why are they implemented?
    \begin{itemize}
        \item Named arguments allow you to specify the name of the parameter that an argument correlates to.
        \item They are implemented by prefacing an argument with the name of the parameter, followed by a colon
                \begin{lstlisting}[language=C++]
                myFunction(x: x_value, y: y_value);\end{lstlisting}
        \item They generally improve code readability without adding any overhead as the compiler rearranges the arguments automatically, and they are especially powerful used in conjunction with optional parameters
    \end{itemize}
    \item What is the different between an argument and a parameter?
    \begin{itemize}
        \item A parameter is a variable used as part of a method signature.
        \item An argument is the value that correlates to a parameter when a method is invoked.
    \end{itemize}
    \item What are optional parameters and how/why are they used?
    \begin{itemize}
        \item Optional parameters are used by defining a default value for a parameter in the method definition.
        \item They allow for an easier to read form of method overloading when the only change made is the number of parameters, not the type of parameters.
        \item They can be used in tandem with named arguments to provide access to a wider set of method overloads.
        \begin{lstlisting}[language=C++]
                private void myFunction(int notOptional, int optional1 = 12, int optional2 = 21);
                myFunction(notOptional: 17, optional2: 65);\end{lstlisting}
    \end{itemize}
    \item What is the \textit{params} keyword and when should it be used?
    \begin{itemize}
        \item The params keyword specifies that an array parameter can take any number of arguments of the appropriate type without first packaging them into an array.
        \item This can lead to more optimized code (as an array object does not need to be created or destroyed), and more concise code (as an array object does not need to be declared and filled).
        \item However, it is also more dangerous to use if there are other parameters of the same type and the order of them may change in the future. This risk can be mitigated with the use of named arguments.
        \begin{lstlisting}[language=C++]
                //Valid
                private void myFunc(params int[] numsToAdd);
                myFunc(1,2,3,...,x);
                
                //Risky because if otherParam is ever moved or removed the old function calls                will still work in unintended ways
                private void myFunc(int otherParam, params int[] numsToAdd);
                myFunc(1,1,2,...,x)

                //Less risky, as the old function calls will now throw errors
                private void myFunc(int otherParam, params int[] numsToAdd);
                myFunc(otherParam: 1, 1,2,...,x)
                \end{lstlisting}
    \end{itemize}
    \item What are the differences between object initializers and constructors?
    \begin{itemize}
        \item Constructors and object initializers are both used to instantiate objects, however object initializers were introduced prior to optional parameters, and exist as a method to reduce the number of constructor overloads.
        \begin{lstlisting}[language=C++]
                //param1 is required and param2 is optional
                
                //Using Method Overloading
                //Also uses tuple syntax to create a multi-parameter expression-bodied                       constructor.
                myConstructor(int param1) => field1 = param1;
                myConstructor(int param1, int param2) => (field1, field2) = (param1, param2);
                myObject = new MyObject(1);
                myObject =new MyObject(1,15);

                //Using object initializers alongside named arguments
                myConstructor(int param1) => field1 = param1;
                myObject = new myObject(1)
                myObject = new MyObject(param1: 1) {field2 = 15}

                //Using optional parameters, named arguments, and tuple syntax
                myConstructor(int param1, int param2=0) => (field1, field2) = (param1, param2);
                myObject = new MyObject(param1: 1);
                myObject = new MyObject(param1: 1, param2: 15);
                \end{lstlisting}
    \end{itemize}
    \item What is constructor chaining and when should it be used?
    \begin{itemize}
        \item Constructor chaining is a special syntax that allows you to automatically call a class constructor from one of its overloaded constructors.
        \begin{lstlisting}[language=C++]
                //The constructor for MyObject will now accept either 1 or 2 arguments, with the             single argument constructor calling the double argument constructor with 0 as                the second argument 
                MyObject(int a) : this(a, 0){}
                MyObject(int a, int b) {doSomething;}
                \end{lstlisting}
        \item Additionally, constructor chaining also allows calling of base class constructors.
        \begin{lstlisting}[language=C++]
                //The constructor for MyDerivedObject takes one argument, and calls the two                  argument constructor of the base class with 0 as the second argument.
                MyDerivedObject(int a) : base(a, 0){}
                \end{lstlisting}
        \item For the most part, optional parameters are a safer alternative to constructor chaining. However constructor chaining exposes more information through reflection than optional parameters.
        \item Constructor chaining can also be used in conjunction with optional constructor parameters to call a base constructor with non-default values
        \begin{lstlisting}[language=C++]
                //The constructor for MyBaseObject takes one or two argument and defaults the                second optional argument to 0
                MyBaseObject(int param1, string classID = "Base Class") {doSomething;}

                //The derived object constructor can now be called with one parameter, while                 passing a set value that differs from the base default to the base constructor               for the second argument
                MyDerivedObject1(int param1):base(param1, "Derived Class 1"){}

                //Now the base class can still be instantiated, the derived class constructors               second argument effectively has a different "default" value than the base class,             and the functionality of the constructor does not need to be duplicated between              the base and derived class (as would be necessary for function overriding)
                \end{lstlisting}
    \end{itemize}
    \item What are static constructors and when should they be used?
    \begin{itemize}
        \item Static constructors are class constructors which are always called at most one time (never if the class is never used)
        \item They are automatically called by the CLR and cannot be manually called.
        \item Static constructors are typically called immediately before the first call to the class, but .NET does not guarantee when they are called and so it should not be relied upon.
        \item The use-case is rather niche, but in the circumstance that you need read-only static fields whose values are not known at compile time, such as reading data from a configuration file, static constructors are a good solution.
        \item Static constructors do have a slight performance impact over simply setting the value at declaration if the value is known at compile-time.
    \end{itemize}
    \item What are ``local functions?"
    \begin{itemize}
        \item 
    \end{itemize}
\end{itemize}


\newpage
\section{C++ Programming}
\subsection{Review Questions}

\newpage
\section{Unity Game Development}
\subsection{Useful Functions to Remember}
\begin{itemize}
    \item Transform.LookAt - Sets the forward vector of the calling transform to be facing towards the target transform
    \begin{lstlisting}[language=C++]
                myTransform.LookAt(Transform target); \end{lstlisting} 
    \item Vector3.Magnitude - Gets the magnitude (length) of a vector
    \begin{lstlisting}[language=C++]
                float distance = vectorToTarget.magnitude; \end{lstlisting}
    \item Vector3.SqrMagnitude - Gets the magnitude (length) of a vector squared. Useful because it is much faster than Vector3.magnitude, as it doesn't require a square root operation.
    \begin{lstlisting}[language=C++]
                float distance = vectorToTarget.sqrMagnitude; \end{lstlisting}
    \item Vector3.Distance - Static, gets the distance between two transforms
    \begin{lstlisting}[language=C++]
                float distance = Vector3.Distance(myPos, targetPos); \end{lstlisting}
    \item Debug.DrawRay - Static, draws a ray from a starting position along a given vector.
    \begin{lstlisting}[language=C++]
                Debug.DrawRay(myPos, vectorToTrack, myColor, durationInSeconds); \end{lstlisting}
    \item Vector3.Dot - Static, calculates the dot product of two vectors.
    \begin{lstlisting}[language=C++]
                float dotProduct = Vector3.Dot(vecA, vecB); \end{lstlisting}
    \item Quarternion.LookRotation - Creates a rotation to look at a given direction based on a given forward and upwards vector. The upwards vector defaults to Vector3.up and forward should be the direction to look.
    \begin{lstlisting}[language=C++]
                Quaternion myRotation = Quaternion.LookRotation(lookAtDirection, Vector3.up); \end{lstlisting}
    \item Quaternion.Slerp - Spherical Linear Interpolation between two quaternions, $startingRot$ and $endingRot$, based on a ratio between $[0,1]$, usually denoted by time.
    \begin{lstlisting}[language=C++]
                transform.rotation = Quaternion.Slerp(startingRot, endingRot, ratio); \end{lstlisting}
\end{itemize}
\subsection{Review Questions}

\newpage
\section{Unreal Engine Game Development}

\subsection{Review Questions}

\newpage
\section{General Mathematics \& Physics}
\subsection{Mathematics}
\begin{itemize}
    \item What is a Dot Product?
    \begin{itemize}
        \item The dot product is the sum of the multiplication of two vectors by their components
        \item To get the dot product of vectors a and b we use the formula $a.x*b.x + a.y*b.y$
        \item A right angle has a dot product of $0$, acute angles have positive dot products, and obtuse angles have negative dot products.
        \item This can be used to identify the relative positioning of an object in space
        \item Additionally the angle $\theta$ can be calculated via the formula $\theta = cos^{-1}(\frac{a \cdot b}{||a||*||b||})$ 
        \item Normalized vectors return $1$ if they face the same direction and $-1$ if they face opposite directions.
    \end{itemize}
    \item What is a Cross Product?
    \begin{itemize}
        \item Cross product returns a vector which is orthogonal to both of its input vectors.
        \item The cross product of vectors $a$ and $b$ can be calculated by the formula:
        $\newline (a.y*b.z - a.z*b.y), (a.z*b.x - a.x*b.z), (a.x*b.y - a.y*b.x)$ 
        \item The sign of the resultant vectors components can show whether a clockwise or counterclockwise turn on a given axis will get the first vector to line up with the second. Positive for clockwise, and negative for counterclockwise.
    \end{itemize}
\end{itemize}
\end{document}
