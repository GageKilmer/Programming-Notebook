\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\usepackage{listings}
\usepackage{xcolor}
\usepackage[margin=0.5in]{geometry}
\usepackage{hyperref} %Must be last package

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=1pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    numbers=none
}

\lstset{style=mystyle}

\title{Programming Notebook}
\author{Gage H. Kilmer}
\date{Last Updated: July 2024}

\begin{document}

\maketitle

\newpage
\tableofcontents

\newpage
\section{General Programming}
\subsection{Review Questions}
\begin{itemize}
    \item What are the four pillars of object oriented programming
    \begin{itemize}
        \item Abstraction: Hiding anything that makes it more difficult for the programmer using your code to understand it. Often takes the form of separating your interface from your implementation.
        \item Inheritance: The process of having a base class, and derived classes which inherit certain traits and features from the base/parent class.
        \item Polymorphism: The ability for a single interface to have multiple implementations. Examples include delegates/function pointers, method overloading, and derived class overrides.
        \item Encapsulation: Closely related to abstraction, encapsulation is about protecting your code by preventing values and methods that are not intended for use by the using programmer, usually through some form of access modifier.
    \end{itemize}
\end{itemize}
\subsection{Algorithms}
\subsubsection{The A* Algorithm}
\begin{itemize}
    \item The A* Algorithm is a node-based pathfinding algorithm which uses a cost value based on distance traveled and distance to goal to determine the best path
    \item The node structure should contain fields for $distanceFromOrigin$, $distanceToEndpoint$, $totalScore$
    and $parentNode$
    \begin{itemize}
        \item $distanceFromOrigin$ is cumulative based on the distance from the previous node
        \item $distanceToEndpoint$ can be any form of distance calculation, like taxicab or direct
        \item $totalCost$ is the sum of $distanceFromOrigin$ and $distanceToEndpint$
    \end{itemize}
    \item The basic process for the A* algorithm is as follows:
    \begin{itemize}
        \item Create two empty lists of nodes, $nodesToCheck$ and $checkedNodes$.
        \item Add the starting node to the list of nodes to check
        \item Check to see if any of the neighboring nodes to the current node are valid, and if so, calculate their $totalCost$ add them to the $nodesToCheck$ list.
        \item Sort the $nodesToCheck$ list by the $totalCost$ of its elements
        \item Move the current node to $checkedNodes$
        \item Grab the first element of $nodesToCheck$, check if it is the destination, and if not, repeat from step 3.
        \item Once the grabbed node is the destination, work backwards through the parents of each node to get the best path.
    \end{itemize}
    \item The $totalCost$ field of a node can incorporate additional information to guide the algorithm towards a more ``ideal" path
    \item There may be an additional value added to $totalCost$ for ``lava tiles" that deal damage to the character walking over them.
    \item This, in turn, disincentivizes the path without outright removing it from consideration.
\end{itemize}

\subsection{Design Patterns}
\subsubsection{Singleton}
\begin{itemize}
    \item Singletons are a design pattern characterized by a class with a single globally accessible instance.
    \item The singleton is implemented by having a private constructor, so that no other instances of the class can be created, and by having a public static instance of the class within its definition that can be accessed from anywhere.
\end{itemize}

\subsubsection{Command}
\begin{itemize}
    \item The command design pattern is a general term that refers to storing a function call as an object. This object can then be passed as an argument to a function, can be added to a queue or invoked at a specified time, and implement undo/redo functionality.
    \item In C++ this can take the form of function pointers, In C\# this is called a delegate. Other languages use the terms first-order function, callback, or closure, each with their own unique properties.
    \item There are four key aspects to the Command structure
    \begin{itemize}
        \item Command Interface: the abstract base class that acts as a framework for minimum functionality any derived command classes need to implement.
        \item Concrete Command Classes: The derived classes of the command interface, which call actually implemented functions from the receiver. The concrete command classes should contain almost no actual implementations, but must contain fields for any necessary parameters of the callback function they invoke.
        \item Receiver: The device that implements the desired functionality. The receiver class can be an abstract base class allowing for greater extensibility via derived classes if desired.
        \item Invoker/Sender: The invoker is the class that actually calls the $command.execute()$ function from a reference to a command instance, and it has no knowledge of the implementation of the underlying method call, or of the command class it is invoking.
    \end{itemize}
    \item An object-oriented implementation to decouple input buttons and game functionality could be as such
    \begin{itemize}
        \item An abstract base Command class with derived classes that implement the game functions as overrides to an invoke function. 
        \item Each input button then invokes the function pointer within the Command class, such that which derived class instance is tied to which input can be changed, allowing for buttons to be remapped
        \item Additionally, if we decouple the actor that is being affected by user inputs from the user inputs, the command structure becomes a powerful interface for AI systems to control any actor that uses the same functionality.
    \end{itemize}
    \item In the previous example, only one instance of the derived classes of Command need to be created, and they can be reused. However, in some cases you may want to keep command instances in a buffer, which allows you to implement an undo function, as is common in many tactical style games.
    \item An important distinction here is that the first example decoupling the actor from the command was a desired feature, as it allowed other units to utilize the same structure. 
\end{itemize}
\subsubsection{Flyweight}
\begin{itemize}
    \item The flyweight is a structural design pattern characterized by separation of the intrinsic and extrinsic state of an object.
    \begin{itemize}
        \item Intrinsic State: Things that never change between instances of an object. Ex. Model, list of potential textures, etc.
        \item Extrinsic State: Things that differ between instances of an object. Ex. Position, Rotation, HP, etc.
    \end{itemize}
    \item In ``Game Programming Patterns" by Robert Nystrom, the flyweight pattern is described as one where there are many instances of a small class which only contains the extrinsic state of the object, and a reference to a single copy of an object which contains the intrinsic state of an object.
    \item This contrasts with \href{https://refactoring.guru/design-patterns/flyweight}{refactoring.guru's} example, where a Factory class creates new instances of the Flyweight class (which contains intrinsic state) if no such instance exists, and returns the existing instance if it does exist. 
    \begin{itemize}
        \item This paradigm has each flyweight (intrinsic) class holding all of the methods relating to the class, with the extrinsic class passing in any necessary information for that method to run.
    \end{itemize}
    \item Personally I feel that, in languages that support static fields, the best way to implement a flyweight-style separation of intrinsic and extrinsic data is via static fields. \item I think that holding the intrinsic state in static fields and extrinsic state in non-static fields has the best balance of performance and readability. \item It is worth noting that with the static field method, each instance of the extrinsic class must contain a reference to the intrinsic data by nature of how static members work. This is not necessarily true using Nystrom's version.
\end{itemize}

\newpage
\section{C\# Programming}

\subsection{Review Questions}
\begin{itemize}
    \item What is .NET?
    \begin{itemize}
        \item .NET is a framework for building windows applications, which supports multiple languages such as C\# and F\#
        \item There are two components to .NET, the Common Language Runtime (CLR) and a class library.
    \end{itemize}
    \item What is the .NET SDK?
    \begin{itemize}
        \item The .NET Standard Developer Kit contains the .NET Command Line Interface (CLI), the .NET runtime, as well as a myriad of tools and libraries to enable a developer to build and deploy applications. 
    \end{itemize}
    \item What is the .NET Runtime?
    \begin{itemize}
        \item The .NET Runtime contains all the necessary infrastructure for a device to run a .NET application.
    \end{itemize}
        \item What is a \textit{self-contained deployment}?
    \begin{itemize}
        \item A self-contained deployment is when an application comes prepackaged with the necessary runtime for it to run.
    \end{itemize}
    \item Is C\# a \textit{managed code} or \textit{unmanaged code} language, and what does that mean?
    \begin{itemize}
        \item C\# is typically used to create managed code, though using the \textit{unsafe} keyword allows you to directly manipulate memory, which makes unmanaged code. Additionally, you can implement interoperability with unmanaged code .dll files.
        \item Managed code is compiled into an intermediate language, to be interpreted by a language runtime, such as the Common Language Runtime (CLR). It typically has automatic memory management (garbage collection) and offers greater cross-platform support, as many of the details of hardware implementation are handled by the runtime.
        \item Unmanaged code is compiled to machine language, and allows greater control over low-level operations, including manual memory management. However it also requires the developer to properly handle the additional responsibilities.
    \end{itemize}
    \item What is ``JIT?"
    \begin{itemize}
        \item JIT is Just In Time Compilation, which is the process by which a runtime converts IL code to machine code.
    \end{itemize}
    \item What is an assembly?
    \begin{itemize}
        \item An assembly is simply a container for related namespaces, and they're typically .exe or .dll files on disk.
    \end{itemize}
    \item What are ``Top-level statements" in C\#?
    \begin{itemize}
        \item Starting with C\#9, simple applications can be written that do not require explicit definitions of a namespace, a main function, or even a class.
    \end{itemize}
    \item What is the \textit{var} keyword and how is it used?
    \begin{itemize}
        \item The var keyword is used to declare a variable using type inference, in essence the compiler interprets the data type that is being stored and treats the variable as such. 
        \item It is necessary to use for anonymous functions, however it is otherwise a stylistic choice that should generally be avoided as it reduces code readability.
    \end{itemize}
    \item What is the \textit{const} keyword?
    \begin{itemize}
        \item The const keyword marks that a variable should never be changed, ideally even in future versions of the program (Otherwise it will need to be recompiled for the change to be reflected).
        \item Variables with the const keyword \textbf{must} be initialized to a value when they are declared, and that value must be known at compile-time (cannot come from another variable).
        \item Additionally, const variables are always static, and cannot be used with the static keyword.
    \end{itemize}
    \item What are ``nullable value types?"
    \begin{itemize}
        \item Nullable value types were introduced in C\#2, and by using the ? operator, it allows you to set value type variables to null
        \item Behind the scenes
        \begin{lstlisting}[language=C++]
            int? myInt; \end{lstlisting} is interpreted by the compiler as
            \begin{lstlisting}[language=C++]
            Nullable<int> myInt; \end{lstlisting}
        \item Nullable types have a property called \textit{hasValue} which returns true if it is not null, and false if it is 
    \end{itemize}
    \item What are ``nullable reference types?"
    \begin{itemize}
        \item Nullable reference types throw compiler warnings when they are not checked for null value, to reduce the risk of \textit{NullReferenceException} errors
        \item Additionally, with this enabled, non-nullable reference types can no longer be set to null without throwing compiler warnings.
        \item C\# 8 introduced nullable reference types, and they must be explicitly enabled.
    \end{itemize}
    \item What is the \textit{?.} operator?
    \begin{itemize}
        \item The ?. operator is called the null-conditional operator, and it checks if the calling object is null before invoking the method. 
        \item Example: \begin{lstlisting}[language=C++]
            myObject?.method(); \end{lstlisting}
        \item The result of a method called this way cannot be assigned to a non-nullable type, as they will return null if the calling object is null.
        \item Valid Example:
            \begin{lstlisting}[language=C++]
            string? objectName = myObject?.getName(); \end{lstlisting} 
    \end{itemize}
    \item What is the \textit{??} operator?
    \begin{itemize}
        \item The coalescing operator is used to return a different value if the left-hand expression evaluates to null.
        \item Example which returns 0 if an int is null:
        \begin{lstlisting}[language=C++]
            int? firstInt = null;
            int? secondInt = firstInt ?? 0\end{lstlisting} 
    \end{itemize}
    \item What is the difference between reference and value types?
    \begin{itemize}
        \item Value types contain the value of the variable, and when they are passed as parameters to functions, a new copy of the value type variable is made.
        \item Reference types instead hold a pointer to the original data, and as such when they are passed as parameters, changes made within the function are reflected in the original.
    \end{itemize}
    \item What are the different value and reference types?
    \begin{itemize}
        \item Reference types: Class, String, Dynamic, Object, Interface, Record, Delegate
        \item Value types: Anything else, notably including structs
    \end{itemize}
    \item What are the different integer types in C\#?
    \begin{itemize}
        \item The byte and sbyte types have 8 bits, and can represent [0,255] and [-128,127] respectively
        \item The short and ushort types have 16 bits, and can represent [-32768, 32767] and [0, 65535] respectively
        \item The int type is a signed 32-bit integer, and uint is an unsigned 32-bit integer
        \item Likewise, long and ulong are 64-bit integers.
        \item Lastly, there is the BigInteger data type, which has no upper and lower bounds, but will dynamically resize itself as long as there is enough memory to do so.
    \end{itemize}
    \item What is the purpose of underscores when working with numerical values?
    \begin{itemize}
        \item They can be used as separators that are ignored by the compiler to improve code readability.
        \item This is especially helpful when working with binary data via the 0b literal.
    \end{itemize}
    \item What are the different floating point types in C\#?
    \begin{itemize}
        \item System.Half is a 16-bit floating point type.
        \item System.Single (float) is a 32-bit floating point type, used by adding an ``f" to the value.
        \item System.Double (double) is a 64-bit floating point type.
        \item System.Decimal (decimal) is a 128-bit floating point type, used my adding an ``m" to the value.
    \end{itemize}
    \item What integer values map to which boolean values in C\#?
    \begin{itemize}
        \item You cannot convert between integers and booleans in C\#.
    \end{itemize}
    \item What is ``pattern matching?"
    \begin{itemize}
        \item Pattern matching allows simpler syntax to check whether data matches some given pattern. There are many types of pattern matching that each have different uses. They are most commonly used with conditional statements, switch statements, and switch expressions.
    \end{itemize}
    \item What are the different types of pattern matching?
    \begin{itemize}
        \item Type Pattern: Checks if the data is castable to a given type. Putting an identifier after the data type does the cast and stores the result to that new variable.
         \begin{lstlisting}[language=C++]
            if(myValue is int)
            if(myValue is int newValue)\end{lstlisting}
        \item Const Pattern: Checks if the data is equal to a given value, including null.
         \begin{lstlisting}[language=C++]
            if(myValue is 32)
            if(myValue is null)\end{lstlisting} 
        \item Relational Pattern: Checks if the data has some given relationship to a given value.
        \begin{lstlisting}[language=C++]
            if(myValue is >= 32)
            switch(myValue)
                case == 3:\end{lstlisting} 
        \item Property Pattern: Checks the value of a named property on the given object.
            \begin{lstlisting}[language=C++]
                if(myString is {Length: 4}) \end{lstlisting} 
        \item Positional Pattern: Checks if a group of values in parentheses match the values in a tuple, positional record, or a type which has a defined \textit{Deconstruct()} method. Any value checked against an underscore is treated as a wildcard.
        
                \begin{lstlisting}[language=C++]
                if(myPair is (false, false))
                if(myCoords is (0.5f, _, 0.5f))\end{lstlisting}
        \item Var Pattern: The var pattern always succeeds, as it doesn't check for anything, but instead stores an expression into a var.
        \begin{lstlisting}[language=C++]
                if(getData() is var myData && myData.value is 32) \end{lstlisting} 
    \end{itemize}

    \item What are Pattern Combinators/Logical Patterns?
    \begin{itemize}
        \item The three pattern combinators are \textit{not, and,} and \textit{or}.
        \item They act as ways to combine multiple patterns together for more complex checking
        \begin{lstlisting}[language=C++]
                if(myValue is < 0 or >100 and not 32) \end{lstlisting} 
    \end{itemize}
    \item What are the differences between Casting, Converting, and Parsing data?
    \begin{itemize}
        \item Casting tells the compiler that one piece of data should be interpreted as a different data type. No data is changed, but data can be lost when casting from a higher precision type to a lower precision type. For example, a float to an int.
        \item Conversion is typically an actual software function call which takes in one data type and returns another. Data may be changed during this call.
        \item Parsing is a special subset of conversion where a string is converted to a different data type if it can properly be represented as such.
    \end{itemize}
    \item What is the difference between the String class and the StringBuilder class?
    \begin{itemize}
        \item Technically strings are an immutable type in C\#, they cannot be modified. If you do someString += "a", you are actually creating an entirely new string object which is inefficient
        \item StringBuilders are a mutable type that allow you to modify strings without creating new objects
    \end{itemize}
    \item What is String Interpolation?
    \begin{itemize}
        \item String interpolation allows you to insert expressions and variables into strings by beginning the string with a \$ and putting any expressions within brackets.
        \begin{lstlisting}[language=C++]
                Console.Writeln($"My name is {Name.first} {Name.last}, and my initials are {Name.first[0] + Name.last[0]}"); \end{lstlisting} 
    \end{itemize}
    \item What is the FormattableString type?
    \begin{itemize}
        \item Formattable strings are strings which contain Format, GetArgument, and ArgumentCount members, which allow you to directly check and write information relating to an interpolated strings formatting.
    \end{itemize}
    \item What are Verbatim Strings?
    \begin{itemize}
        \item Verbatim strings ignore any escape characters and are stored exactly as they are written.
        \item They are declared by prefixing a string with the @ symbol.
        \begin{lstlisting}[language=C++]
                Console.Writeln(@"C:\Users\User"); \end{lstlisting} 
    \end{itemize}
    \item What are the different access modifiers in C\#?
    \begin{itemize}
        \item Public: Accessible from anywhere in the code.
        \item Private: Accessible only from the containing class.
        \item Protected: Accessible from the containing class and any derived classes.
        \item Internal: Accessible from the containing class and anywhere in the same assembly 
        \item Protected Internal: Accessible from the containing class, anywhere in the same assembly, and derived classes anywhere.
        \item Private Protected: Accessible only from the containing class and derived classes \textbf{in the same assembly}.
    \end{itemize}
    \item What are the differences between the \textit{const} and \textit{readonly} keywords?
    \begin{itemize}
        \item Const fields are known at compile-time, and they cannot be changed at all once set. They must be initialized to a value when declared, and are always intrinsically static.
        \item Readonly fields are able to be set at runtime, and they can be changed without limitation within the constructor of the containing object. They can be static or instance variables.
    \end{itemize}
    \item What are the differences between the equivalence semantics for value and reference types?
    \begin{itemize}
        \item When checking if two value types are equal, the default behaviour is to return true if every data member of the $a$ and $b$ are equal.
        \item When checking if two reference types are equal, the default behaviour is to return true only if both $a$ and $b$ point to the same location in memory.
        \item These behaviours can be changed by overriding the Equals and GetHashCode functionality.
    \end{itemize}
    \item What are ``Properties" in C\#?
    \begin{itemize}
        \item Properties are private fields made accessible through getter and setter accessor functions.
        \item Accessor functions can be auto-implemented, and may also allow for default values to be set.
        \begin{lstlisting}[language=C++]
                public int MyInt {get; set;} = 112; \end{lstlisting} 
        \item Auto-implemented accessors can have their accessibility explicitly set.
        \begin{lstlisting}[language=C++]
                public int MyInt {public get; private set;} = 112; \end{lstlisting}
        \item Properties can be made readonly by simply not implementing a set accessor.
        \begin{lstlisting}[language=C++]
                public int MyInt {get; } = 112; \end{lstlisting}
        \item Properties can be accessed as if they were public fields without breaking encapsulation.
    \end{itemize}
    \item What are ``expression-bodied properties"?
    \begin{itemize}
        \item Expression-bodied properties are read-only properties implemented with the $=>$ syntax.
        \item The compiler automatically generates a public get accessor for the property
         \begin{lstlisting}[language=C++]
                private readonly string ReturnThisValue;
                public string CallThisAccessor => ReturnThisValue;\end{lstlisting}
    \end{itemize}
    \item What are ``init-only set accessors"?
    \begin{itemize}
        \item Init-only set accesssors are used to create set accessors which can only be used from a constructor or an object initializer.
        \begin{lstlisting}[language=C++]
                public class MyClass
                {
                    public string initOnly {get; init;} = "Default";
                }
                //Valid
                myClass = new MyClass(){initOnly = "New Value";}

                //Not valid
                myClass = new MyClass();
                myClass.initOnly = "New Value";
                \end{lstlisting}
    \end{itemize}
    \item What is the difference between a function and a method in C\# nomenclature?
    \begin{itemize}
        \item Methods specifically refer to callable code chunks which may accept parameters and may return values.
        \item Function members are a more general term that includes methods, but may also refer to any non-data member of a class.
    \end{itemize}
    \item What is an ``Expression-Bodied Method?"
    \begin{itemize}
        \item An expression-bodied method is a method which only contains a single statement and is written using the $=>$ syntax;
        \begin{lstlisting}[language=C++]
                private void myFunction() => doSomething;\end{lstlisting}
    \end{itemize}
    \item What is method overloading?
    \begin{itemize}
        \item Method overloading is a form of compile-time polymorphism that allows you to define the same method using multiple different input parameters to call different implementations.
        \item Additionally, an overloaded method can invoke a different overload of the same method within its implementation.
    \end{itemize}
    \item What are named arguments and how/why are they implemented?
    \begin{itemize}
        \item Named arguments allow you to specify the name of the parameter that an argument correlates to.
        \item They are implemented by prefacing an argument with the name of the parameter, followed by a colon
                \begin{lstlisting}[language=C++]
                myFunction(x: x_value, y: y_value);\end{lstlisting}
        \item They generally improve code readability without adding any overhead as the compiler rearranges the arguments automatically, and they are especially powerful used in conjunction with optional parameters
    \end{itemize}
    \item What is the different between an argument and a parameter?
    \begin{itemize}
        \item A parameter is a variable used as part of a method signature.
        \item An argument is the value that correlates to a parameter when a method is invoked.
    \end{itemize}
    \item What are optional parameters and how/why are they used?
    \begin{itemize}
        \item Optional parameters are used by defining a default value for a parameter in the method definition.
        \item They allow for an easier to read form of method overloading when the only change made is the number of parameters, not the type of parameters.
        \item They can be used in tandem with named arguments to provide access to a wider set of method overloads.
        \begin{lstlisting}[language=C++]
                private void myFunction(int notOptional, int optional1 = 12, int optional2 = 21);
                myFunction(notOptional: 17, optional2: 65);\end{lstlisting}
    \end{itemize}
    \item What is the \textit{params} keyword and when should it be used?
    \begin{itemize}
        \item The params keyword specifies that an array parameter can take any number of arguments of the appropriate type without first packaging them into an array.
        \item This can lead to more optimized code (as an array object does not need to be created or destroyed), and more concise code (as an array object does not need to be declared and filled).
        \item However, it is also more dangerous to use if there are other parameters of the same type and the order of them may change in the future. This risk can be mitigated with the use of named arguments.
        \begin{lstlisting}[language=C++]
                //Valid
                private void myFunc(params int[] numsToAdd);
                myFunc(1,2,3,...,x);
                
                //Risky because if otherParam is ever moved or removed the old function calls                will still work in unintended ways
                private void myFunc(int otherParam, params int[] numsToAdd);
                myFunc(1,1,2,...,x)

                //Less risky, as the old function calls will now throw errors
                private void myFunc(int otherParam, params int[] numsToAdd);
                myFunc(otherParam: 1, 1,2,...,x)
                \end{lstlisting}
    \end{itemize}
    \item What are the differences between object initializers and constructors?
    \begin{itemize}
        \item Constructors and object initializers are both used to instantiate objects, however object initializers were introduced prior to optional parameters, and exist as a method to reduce the number of constructor overloads.
        \begin{lstlisting}[language=C++]
                //param1 is required and param2 is optional
                
                //Using Method Overloading
                //Also uses tuple syntax to create a multi-parameter expression-bodied                       constructor.
                myConstructor(int param1) => field1 = param1;
                myConstructor(int param1, int param2) => (field1, field2) = (param1, param2);
                myObject = new MyObject(1);
                myObject =new MyObject(1,15);

                //Using object initializers alongside named arguments
                myConstructor(int param1) => field1 = param1;
                myObject = new myObject(1)
                myObject = new MyObject(param1: 1) {field2 = 15}

                //Using optional parameters, named arguments, and tuple syntax
                myConstructor(int param1, int param2=0) => (field1, field2) = (param1, param2);
                myObject = new MyObject(param1: 1);
                myObject = new MyObject(param1: 1, param2: 15);
                \end{lstlisting}
    \end{itemize}
    \item What is constructor chaining and when should it be used?
    \begin{itemize}
        \item Constructor chaining is a special syntax that allows you to automatically call a class constructor from one of its overloaded constructors.
        \begin{lstlisting}[language=C++]
                //The constructor for MyObject will now accept either 1 or 2 arguments, with the             single argument constructor calling the double argument constructor with 0 as                the second argument 
                MyObject(int a) : this(a, 0){}
                MyObject(int a, int b) {doSomething;}
                \end{lstlisting}
        \item Additionally, constructor chaining also allows calling of base class constructors.
        \begin{lstlisting}[language=C++]
                //The constructor for MyDerivedObject takes one argument, and calls the two                  argument constructor of the base class with 0 as the second argument.
                MyDerivedObject(int a) : base(a, 0){}
                \end{lstlisting}
        \item For the most part, optional parameters are a safer alternative to constructor chaining. However constructor chaining exposes more information through reflection than optional parameters.
        \item Constructor chaining can also be used in conjunction with optional constructor parameters to call a base constructor with non-default values
        \begin{lstlisting}[language=C++]
                //The constructor for MyBaseObject takes one or two argument and defaults the                second optional argument to 0
                MyBaseObject(int param1, string classID = "Base Class") {doSomething;}

                //The derived object constructor can now be called with one parameter, while                 passing a set value that differs from the base default to the base constructor               for the second argument
                MyDerivedObject1(int param1):base(param1, "Derived Class 1"){}

                //Now the base class can still be instantiated, the derived class constructors               second argument effectively has a different "default" value than the base class,             and the functionality of the constructor does not need to be duplicated between              the base and derived class (as would be necessary for function overriding)
                \end{lstlisting}
    \end{itemize}
    \item What are static constructors and when should they be used?
    \begin{itemize}
        \item Static constructors are class constructors which are always called at most one time (never if the class is never used)
        \item They are automatically called by the CLR and cannot be manually called.
        \item Static constructors are typically called immediately before the first call to the class, but .NET does not guarantee when they are called and so it should not be relied upon.
        \item The use-case is rather niche, but in the circumstance that you need read-only static fields whose values are not known at compile time, such as reading data from a configuration file, static constructors are a good solution.
        \item Static constructors do have a slight performance impact over simply setting the value at declaration if the value is known at compile-time.
    \end{itemize}
    \item What are ``local functions?"
    \begin{itemize}
        \item Local functions are functions declared inside of a method, where the method is the scope, and as such they can only be called from within that method.
        \item If a local function is declared static, it cannot use any variables from the containing method or any instance variables of the containing class, but the compiler is able to perform additional optimizations
        \item If a local function is not static, it \textbf{must} be defined after any method-local variables it intends to use.
    \end{itemize}
    \item What are ``Generic Methods" and how are they used?
    \begin{itemize}
        \item Generic methods are methods which allow multiple types of variables to be passed in.
        \item Each ``wildcard type" must be included in triangle brackets after the method name but before the parameter list.
        \begin{lstlisting}[language=C++]
            //T1 and T2 represent the two generic types 
            private bool AreTypesSame<T1, T2>(T1 object1, T2, object2)
            {
                return typeOf(T1) == typeOf(T2);
            }\end{lstlisting}
    \end{itemize}
    \item What are extension methods?
    \begin{itemize}
        \item Extension methods are methods added to a class which the defining code does not have direct access to.
        \item Extension methods \textbf{must} be static and within a static class, however they are called like instance methods
        \item They are implemented by using the $this$ keyword before the first parameter, of the type being extended.
        \begin{lstlisting}[language=C++]
            //The first parameter marks this function as an extension method, and does NOT               require an argument to be used in the method call
            static class IntExtensions
            {
                public static int DoubleValue(this int value) => return value*2;
            }
            
            //Which can then be called as
            int doubled = myInt.DoubleValue();\end{lstlisting}
    \end{itemize}
    \item What are anonymous types and when should they be used?
    \begin{itemize}
        \item Anonymous types are types which do not have identifiers associated with them, and they are mostly used in LINQ queries where paring down the amount of data being returned by a query is desired.
        \item They are declared using the $new$ keyword, and they cannot be passed into functions, used as return types, or used to explicitly set field types.
        \item They are mutable without destruction through the use of the $with$ keyword
        \begin{lstlisting}[language=C++]
            var apple = new {name = "Apple", cost = 1.25};
            var saleApple = apple with {cost=0.79}; \end{lstlisting}
    \end{itemize}
    \item What are the differences between class, record, and struct?
    \begin{itemize}
        \item Classes are reference types, and use reference equivalence semantics. They can be mutable or immutable depending on the properties they contain.
        \item Records are reference types that use value equivalence semantics, making them ideal for data-centric classes. They are immutable by default but can be made mutable, and cannot contain any non-data members. 
        \item Structs are value types that use value equivalence semantics. Because they are value types, they are stored on the stack by default. Structs always have a default constructor, even if a non-default constructor is defined, and they do \textbf{NOT} support inheritance.
    \end{itemize}
    \item What is ``boxing" and when does it occur?
    \begin{itemize}
        \item Boxing is the process of turning a value type variable into a reference type variable.
        \item It occurs when value types are used as the right-hand side of a set operator and the left-hand side is a reference type variable.
    \end{itemize}
    \item What is the \textit{checked} keyword?
    \begin{itemize}
        \item The checked keyword ensures that if a variable is overflowing within the code block it encapsulates, an exception will be thrown rather than allowing the overflow.
    \end{itemize}
    \item What is the difference between implicit and explicit conversion?
    \begin{itemize}
        \item Implicit conversion happens when there is a guarantee that there is no data loss between two data types. For example, converting from a short to an int.
        \item Explicit conversion happens when there is not a guarantee that there is no data loss between two data types, but the conversion is still valid. For example, converting from an int to a byte.
        \begin{lstlisting}[language=C++]
            int i = 277;
            byte b = (byte)i;\end{lstlisting}
    \end{itemize}
    \item How do you convert between data types that do not support implicit or explicit conversion?
    \begin{itemize}
        \item Use the built-in $Parse()$ and $TryParse()$ functions that are part of each primitive data type
        \item Additionally, .NET provides a $Convert$ class with functions such as $Convert.ToInt32()$
        \item Lastly, conversions can be built as members of custom classes, or through the use of extension methods.
    \end{itemize}
    \item What does the static $string.join()$ do?
    \begin{itemize}
        \item It takes two parameters, a ``separator" which is inserted between each element of the second parameter, an array. It returns a string with the combined data.
    \end{itemize}
\end{itemize}


\newpage
\section{C++ Programming}
\subsection{Review Questions}

\newpage
\section{Unity Game Development}
\subsection{Useful Functions to Remember}
\begin{itemize}
    \item Transform.LookAt - Sets the forward vector of the calling transform to be facing towards the target transform
    \begin{lstlisting}[language=C++]
                myTransform.LookAt(Transform target); \end{lstlisting} 
    \item Vector3.Magnitude - Gets the magnitude (length) of a vector
    \begin{lstlisting}[language=C++]
                float distance = vectorToTarget.magnitude; \end{lstlisting}
    \item Vector3.SqrMagnitude - Gets the magnitude (length) of a vector squared. Useful because it is much faster than Vector3.magnitude, as it doesn't require a square root operation.
    \begin{lstlisting}[language=C++]
                float distance = vectorToTarget.sqrMagnitude; \end{lstlisting}
    \item Vector3.Distance - Static, gets the distance between two transforms
    \begin{lstlisting}[language=C++]
                float distance = Vector3.Distance(myPos, targetPos); \end{lstlisting}
    \item Debug.DrawRay - Static, draws a ray from a starting position along a given vector.
    \begin{lstlisting}[language=C++]
                Debug.DrawRay(myPos, vectorToTrack, myColor, durationInSeconds); \end{lstlisting}
    \item Vector3.Dot - Static, calculates the dot product of two vectors.
    \begin{lstlisting}[language=C++]
                float dotProduct = Vector3.Dot(vecA, vecB); \end{lstlisting}
    \item Quarternion.LookRotation - Creates a rotation to look at a given direction based on a given forward and upwards vector. The upwards vector defaults to Vector3.up and forward should be the direction to look.
    \begin{lstlisting}[language=C++]
                Quaternion myRotation = Quaternion.LookRotation(lookAtDirection, Vector3.up); \end{lstlisting}
    \item Quaternion.Slerp - Spherical Linear Interpolation between two quaternions, $startingRot$ and $endingRot$, based on a ratio between $[0,1]$, usually denoted by time.
    \begin{lstlisting}[language=C++]
                transform.rotation = Quaternion.Slerp(startingRot, endingRot, ratio); \end{lstlisting}
    \item Profiler.beginSample("name")/Profiler.endSample() - Any code between these two statements shows up in the heirarchy view of the profiler using the name passed into beginSample as a label. 
\end{itemize}
\subsection{Review Questions}
\begin{itemize}
    \item What is a cookie?
    \begin{itemize}
        \item Cookies are masks that are placed on lights to change the shadows the light creates, such as their color or shape.
    \end{itemize}
    \item What are the five steps of the asset workflow?
    \begin{itemize}
        \item Import - Bring content in from outside sources, such as textures, sounds, 3d models
        \item Create - use that content to create something within the unity editor
        \item Build - build your project and any associated asset bundles
        \item Distribute - Send your project to end users
        \item Load - load updates at runtime
    \end{itemize}
    \item What is a mesh?
    \begin{itemize}
        \item A mesh is a 3D wireframe, like a skeleton, that describes the shape of an object.
        \item Meshes are made up of many 2d polygons bounded by vertices in 3d space.
    \end{itemize}
    \item What are normals?
    \begin{itemize}
        \item Normals are parts of mesh data that informs the direction that polygons are facing, which help create curved imagery from flat polygons.
        \item The shader is responsible for drawing the mesh properly given its vertex and normal data.
    \end{itemize}
    \item What is the difference between the ``mesh filter" and ``mesh renderer" components?
    \begin{itemize}
        \item The mesh filter component contains the vertex information for a mesh. Swapping this out allows you to change the shape of an object without fully replacing it.
        \item Meanwhile, the mesh renderer component contains information about how the object should be drawn, such as its material.
    \end{itemize}
    \item What is a shader?
    \begin{itemize}
        \item A shader is a script which contains properties that determine how an object is rendered by the render pipeline.
        \item They are often pipeline specific, and each pipeline comes with a set of default shaders built for it.
    \end{itemize}
    \item What are the two main types of shading performed by shaders?
    \begin{itemize}
        \item Fragment Shading/Pixel Shading - represents mesh surfaces and generates pixel color on output image
        \item Vertex Shading - Operates on the vertices of a mesh, typically to make them move. (think moving water)
        \item Shaders are typically called Fragment Shaders or Vertex Shaders based on what they do, but technically any shader can do both.
    \end{itemize}
    \item What is the difference between physically based rendering and non-physically based rendering?
    \begin{itemize}
        \item Physically based rendering (PBR) has the qualities of lights and surfaces remain separate, and the renderer determines how light interacts with the scene to create lighting that more accurately matches reality
        \item Non-physically based rendering typically has the properties of shadows, lighting, and reflections handled manually without a lighting physics engine. This is often used for more stylized graphics such as ``cartoon" games.
    \end{itemize}
    \item What is the relationship between materials and shaders?
    \begin{itemize}
        \item Shaders determine what an object \textit{can} look like, whereas a material determines what an object \textit{does} look like.
    \end{itemize}
    \item What are the two types of light reflection and how do they differ?
    \begin{itemize}
        \item Specular Reflections - The direct reflection of the light, which is most visible on shiny objects. Think about the bright spot on an object where light hits it directly.
        \item Diffuse Reflections - The light that is not absorbed or specular reflected is then diffuse reflected off of the object. Determines the visible color of an object. For example, the brown light that hits my eyes after bouncing off of my desk.
    \end{itemize}
    \item What element of a material refers to the diffuse reflection?
    \begin{itemize}
        \item While not exactly the same thing, different shaders use the terms \textit{base map}, \textit{albedo}, and \textit{diffuse map.}
    \end{itemize}
    \item What is ``albedo?"
    \begin{itemize}
        \item Albedo describes the light diffusion of an object, with luminosity being the amount of light that is diffused when using the HSL color space.
    \end{itemize}
    \item What is the difference between a map and a texture?
    \begin{itemize}
        \item Maps are 2D images which wrap around 3d objects to give them certain visual properties
        \item Textures are files which contain maps.
    \end{itemize}
    \item What is the difference between the specular and metallic material workflows?
    \begin{itemize}
        \item The metallic workflow has a ``metallic" value which is modified by the ``R" channel of the set map, and the color of specular reflections is determined by the albedo color.
        \item The specular workflow has a ``specular" field which uses the RGB channels of the given map to expressly state the color that specular lighting should be.
    \end{itemize}
    \item Why might only half of an object with the ``Transparent" surface type become see-through?
    \begin{itemize}
        \item By default, the renderer only renders the front of an object, but transparent objects need the whole object rendered.
        \item This can be done by setting the ``Render Face" field in the material to ``both."
    \end{itemize}
    \item What is ``Bump Mapping?"
    \begin{itemize}
        \item Bump mapping is the process of using textures (i.e. normal maps) to simulate the texture of an object without changing the mesh.
    \end{itemize}
    \item Why are normal maps mostly cyan and purple?
    \begin{itemize}
        \item The RGB channels of a normal map represent the direction of a pixel relative to the face of the mesh.
        \item RGB channels map to XYZ axis and the blue channel is the most commonly used for normal map features.
    \end{itemize}
    \item How do shaders read heightmaps?
    \begin{itemize}
        \item heightmaps are typically grayscale images, but the shader only reads the green channel.
    \end{itemize}
    \item What is occlusion?
    \begin{itemize}
        \item Occlusion is the blockage of light by an object.
    \end{itemize}
    \item How do occlusion maps work?
    \begin{itemize}
        \item Sometimes, light doesn't behave in desired ways when creating shadows. Occlusion maps are grayscale images that represent light and darkness across an object.
    \end{itemize}
    \item What is the ``Detail Inputs" section of a material used for, and what are it's three main components?
    \begin{itemize}
        \item The detail inputs section is used for microsurface mapping, creating small details too fine for your normal maps.
        \item The normal map component - used for getting minute textural details, such as pores.
        \item The base map component - used for small colors, such as individual threads in a piece of fabric
        \item The mask component - Defines which areas are and are not supposed to be affecting by the normal and base maps in this section.
    \end{itemize}
    \item What are emissive maps and how do you use them?
    \begin{itemize}
        \item Emissive maps determine which parts of an object, if any, give off light.
        \item Any non-black area of an emissive map gives off it's color as light.
    \end{itemize}
    \item What is shader graph?
    \begin{itemize}
        \item Shader graph is unity's solution for creating custom shaders.
    \end{itemize}
    \item What is the difference between direct and indirect lighting?
    \begin{itemize}
        \item Direct Lighting - Hits a surface, reflects off of it once, and then hits a sensor
        \item Indirect Lighting - Hits multiple via reflection before hitting a sensor.
    \end{itemize}
    \item What is global illumination?
    \begin{itemize}
        \item Global illumination is a system which simulates both direct and indirect lighting.
    \end{itemize}
    \item What are the two global illumination systems in unity?
    \begin{itemize}
        \item Baked Global Illumination System 
        \item Realtime Illumination System
    \end{itemize}
    \item What are the three parts of the baked global illumination system in unity?
    \begin{itemize}
        \item Lightmapping via the progressive lightmapper
        \item Light probes
        \item Reflection Probes
    \end{itemize}
    \item What are the two parts of the realtime illumination system in unity?
    \begin{itemize}
        \item Lightmapping via the deprecated ``Enlighten lightmapper"
        \item Light probes.
    \end{itemize}
    \item What is lightmapping?
    \begin{itemize}
        \item lightmapping is the technique of pre-calcuating the brightness of surfaces and storing them in a ``lightmap" texture.
    \end{itemize}
    \item What are light probes?
    \begin{itemize}
        \item Light probes give information about light in the empty areas of a scene.
    \end{itemize}
    \item What are reflection probes?
    \begin{itemize}
        \item A unity tool which allows for better reflections
    \end{itemize}
    \item What is the difference between baked and realtime lighting?
    \begin{itemize}
        \item Baked lighting is calculated before runtime, and as such is much more efficient to render at the cost of being less responsive to moving objects within a scene.
        \item Realtime lighting is calculated during runtime, making it computationally expensive in complex scenes, but is extremely responsive to changes in the scene.
        \item It's worth noting that realtime and baked lighting are not mutually exclusive and often work best in tandem.
    \end{itemize}
    \item What are some of the different types of lighting?
    \begin{itemize}
        \item Ambient Lighting - Does not come from a source, a baseline level of light. Also called ``diffuse environmental light" in unity.
        \item Natural Lighting - Usually the sun or moon
        \item Motivated Lighting - Light from a specific source that exists in the scene
        \item Key Lighting - Light that doesn't come from an identifiable source but highlights something in the scene.
    \end{itemize}
    \item What is a skybox?
    \begin{itemize}
        \item A skybox is effectively a giant cube around a scene which is textured on the inside to provide a background.
    \end{itemize}
    \item What are the two types of skyboxes?
    \begin{itemize}
        \item Textured - The appearance is determined by a texture element on the skybox
        \item Procedural - The appearance is generated by the shader based on some predefined constraints.
    \end{itemize}
\end{itemize}

\newpage
\section{Unreal Engine Game Development}
\subsection{Review Questions}

\newpage
\section{General Game Development}
\subsection{3D Modeling}
\begin{itemize}
    \item What is the difference between a normal map, heightmap, bump map?
    \begin{itemize}
        \item They are all the same thing, which describe 
    \end{itemize}
    \item What are UVs?
    \begin{itemize}
        \item Basically, the skin of the model. It is where you put textures on, as well as being involved in how lighting is calculated, depending on how your lighting engine works.
    \end{itemize}
    \item What is a UV Shell?
    \begin{itemize}
        \item A section of the UVs that is cut off from the rest of the UV's, so that it can be stretched and resized without affecting other parts of the model?
    \end{itemize}
    \item What is texture space?
    \begin{itemize}
        \item Texture space is a [0,1] space in which the textures for a 3d object are mapped and stored. Each shell takes up space in texture space.
        \item There are no absolute sizes in texture space, however it is more challenging to draw, even in higher resolutions, on smaller areas. Additionally, higher resolution textures take up more space on disc and in RAM.
    \end{itemize}
    \item What is UV stacking?
    \begin{itemize}
        \item Stacking multiple identical UV shells on top of each other to save texture space, so that each individual one does not need to be painted and the same level of detail can be achieved without inflating the size of the texture file.
    \end{itemize}
    \item What is a ``Texel"?
    \item When is it important to have consistent texel sizes for different UV shells on a model and why?
\end{itemize}

\newpage
\section{Web Design}
\subsection{Blazor}
\begin{itemize}
    \item What is a component?
    \begin{itemize}
        \item Components are reusable bits of UI which contain functionality and are the fundamental building blocks of Blazor development.
        \item Blazor components use the .razor file type.
    \end{itemize}
    \item What are the two parts of a Blazor component?
    \begin{itemize}
        \item HTML template - determines how the UI looks
        \item C\# methods - define the functionality
    \end{itemize}
\end{itemize}

\newpage
\section{General Mathematics \& Physics}
\subsection{Mathematics}
\begin{itemize}
    \item What is a Dot Product?
    \begin{itemize}
        \item The dot product is the sum of the multiplication of two vectors by their components
        \item To get the dot product of vectors a and b we use the formula $a.x*b.x + a.y*b.y$
        \item A right angle has a dot product of $0$, acute angles have positive dot products, and obtuse angles have negative dot products.
        \item This can be used to identify the relative positioning of an object in space
        \item Additionally the angle $\theta$ can be calculated via the formula $\theta = cos^{-1}(\frac{a \cdot b}{||a||*||b||})$ 
        \item Normalized vectors return $1$ if they face the same direction and $-1$ if they face opposite directions.
    \end{itemize}
    \item What is a Cross Product?
    \begin{itemize}
        \item Cross product returns a vector which is orthogonal to both of its input vectors.
        \item The cross product of vectors $a$ and $b$ can be calculated by the formula:
        $\newline (a.y*b.z - a.z*b.y), (a.z*b.x - a.x*b.z), (a.x*b.y - a.y*b.x)$ 
        \item The sign of the resultant vectors components can show whether a clockwise or counterclockwise turn on a given axis will get the first vector to line up with the second. Positive for clockwise, and negative for counterclockwise.
    \end{itemize}
\end{itemize}

\newpage
\section{Helpful References}
\begin{itemize}
    \item \href{https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html}{Unity Shader Material Charts}
\end{itemize}
\end{document}
